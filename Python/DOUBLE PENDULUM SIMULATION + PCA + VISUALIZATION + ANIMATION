# -------------------------------------------------------------------
# DOUBLE PENDULUM SIMULATION + PCA + VISUALIZATION + ANIMATION
# Fully updated with interactive animation and fading trails
# -------------------------------------------------------------------

import numpy as np
from scipy.integrate import solve_ivp
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# ----------------------------
# Double pendulum parameters
# ----------------------------
m1 = m2 = 1.0
l1 = l2 = 1.0
g = 9.81

def deriv(t, y):
    theta1, z1, theta2, z2 = y
    c = np.cos(theta1 - theta2)
    s = np.sin(theta1 - theta2)
    denom1 = (m1 + m2) * l1 - m2 * l1 * c**2
    denom2 = (l2 / l1) * denom1
    z1_dot = ((m2 * l2 * z2**2 * s - m2 * g * np.sin(theta2) * c - (m1 + m2) * g * np.sin(theta1)) / denom1)
    z2_dot = (((m1 + m2) * (l1 * z1**2 * s - g * np.sin(theta2) + g * np.sin(theta1) * c)) / denom2)
    return [z1, z1_dot, z2, z2_dot]

# ----------------------------
# Simulation settings
# ----------------------------
num_trajectories = 100
t_span = (0, 20)
t_eval = np.linspace(*t_span, 300)  # fewer points for speed

all_data = []

# ----------------------------
# Simulate trajectories
# ----------------------------
for traj_id in range(num_trajectories):
    y0 = [
        np.pi/2 + np.random.uniform(-0.01, 0.01),
        0,
        np.pi/2 + np.random.uniform(-0.01, 0.01),
        0
    ]
    sol = solve_ivp(deriv, t_span, y0, t_eval=t_eval, method='RK23')
    traj_data = np.vstack([sol.t, sol.y, np.full(sol.t.shape, traj_id)]).T
    all_data.append(traj_data)
    print(f"Simulated trajectory {traj_id+1}/{num_trajectories}")

all_data = np.vstack(all_data)
np.savetxt("double_pendulum_batch.csv", all_data, delimiter=",",
           header="t,theta1,theta1_dot,theta2,theta2_dot,trajectory_id", comments='')

print(f"{num_trajectories} trajectories saved to double_pendulum_batch.csv")

# ----------------------------
# Prepare PCA
# ----------------------------
X_all = np.copy(all_data[:,1:5])
# Wrap angles between -pi and pi
X_all[:,0] = ((X_all[:,0] + np.pi) % (2*np.pi)) - np.pi
X_all[:,2] = ((X_all[:,2] + np.pi) % (2*np.pi)) - np.pi
X_scaled = StandardScaler().fit_transform(X_all)

pca2 = PCA(n_components=2)
X_pca2 = pca2.fit_transform(X_scaled)
print("Explained variance ratio (2D PCA):", pca2.explained_variance_ratio_)

pca3 = PCA(n_components=3)
X_pca3 = pca3.fit_transform(X_scaled)
print("Explained variance ratio (3D PCA):", pca3.explained_variance_ratio_)

# ----------------------------
# 2D PCA scatter (all trajectories)
# ----------------------------
plt.figure(figsize=(8,8))
for traj_id in range(num_trajectories):
    indices = all_data[:,-1] == traj_id
    plt.scatter(X_pca2[indices,0], X_pca2[indices,1], s=2, alpha=0.5)
plt.xlabel("PC1")
plt.ylabel("PC2")
plt.title("Double Pendulum PCA Projection (all trajectories)")
plt.grid(True)
plt.show()

# ----------------------------
# Animation of 2D PCA trajectories with fading trails
# ----------------------------
fig, ax = plt.subplots(figsize=(8,8))
ax.set_xlim(np.min(X_pca2[:,0])-1, np.max(X_pca2[:,0])+1)
ax.set_ylim(np.min(X_pca2[:,1])-1, np.max(X_pca2[:,1])+1)
ax.set_xlabel("PC1")
ax.set_ylabel("PC2")
ax.set_title("Double Pendulum PCA Trajectories Over Time")

trajectory_dict = {traj_id: X_pca2[all_data[:,-1]==traj_id] for traj_id in range(num_trajectories)}

# Colormap for trajectories
colors = plt.cm.tab20(np.linspace(0, 1, num_trajectories))

# Initialize scatter for current positions (no colors yet)
scat = ax.scatter([], [], s=20, alpha=0.8)

# Fading trails: maintain last N points per trajectory
trail_length = 20
trail_dots = [ax.plot([], [], marker='o', linestyle='', markersize=5,
                      alpha=0.3, color=colors[traj_id])[0]
              for traj_id in range(num_trajectories)]

def update(frame):
    positions = []
    for traj_id in range(num_trajectories):
        traj = trajectory_dict[traj_id]
        if frame < traj.shape[0]:
            positions.append(traj[frame])
        else:
            positions.append(traj[-1])
        # update trail
        start = max(frame-trail_length,0)
        trail = traj[start:frame+1]
        trail_dots[traj_id].set_data(trail[:,0], trail[:,1])
    positions = np.array(positions)
    scat.set_offsets(positions)
    scat.set_color(colors)  # dynamically assign colors
    ax.set_title(f"Time = {t_eval[frame]:.2f}s")
    return [scat]+trail_dots

ani = animation.FuncAnimation(fig, update, frames=len(t_eval),
                              interval=50, blit=False)  # blit=False for compatibility

# Optional: save animation
# ani.save("double_pendulum_pca.mp4", fps=20, dpi=150)
# ani.save("double_pendulum_pca.gif", writer='imagemagick', fps=20)

plt.show()
